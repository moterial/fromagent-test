{"ast":null,"code":"import { useState, useRef, createElement, Fragment } from 'react';\nimport compose from 'compose-function';\n\nvar askForMic = function askForMic() {\n  try {\n    return Promise.resolve(navigator.mediaDevices.getUserMedia({\n      audio: true,\n      video: false\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nvar stopRecording = function stopRecording(recorder) {\n  return function () {\n    return proccesAudio(recorder);\n  };\n};\n\nvar createPlayerStop = function createPlayerStop(_stopRecording) {\n  return function () {\n    var audio = _stopRecording();\n\n    return {\n      player: new Audio(audio.audioUrl),\n      audio: audio\n    };\n  };\n};\n\nvar record = compose(createPlayerStop, stopRecording, setUpRecording);\n\nfunction AudioRecorder() {\n  var micRef = {\n    current: {}\n  };\n  var recorder = {\n    current: {}\n  };\n  var recording = {};\n\n  var startRecord = function startRecord() {\n    if (micRef && micRef.current) {\n      recorder.current = record(micRef.current);\n    }\n  };\n\n  var stopRecord = function stopRecord() {\n    Object.assign(recording, recorder.current());\n  };\n\n  askForMic().then(function (stream) {\n    if (!stream) throw new Error('no source to record from');\n    micRef.current = stream;\n    startRecord();\n  });\n  return {\n    startRecord: startRecord,\n    stopRecord: stopRecord,\n    recording: recording\n  };\n}\n\nfunction setUpRecording(stream) {\n  var context = new AudioContext({\n    sampleRate: 44100\n  });\n  var sampleRate = context.sampleRate;\n  var stats = {\n    leftChannel: [],\n    rightChannel: [],\n    recordingLength: 0\n  };\n  var audioInput = context.createMediaStreamSource(stream);\n  var analyser = context.createAnalyser();\n  audioInput.connect(analyser);\n  var bufferSize = 2048;\n  var recorder = context.createScriptProcessor(bufferSize, 2, 2);\n  analyser.connect(recorder);\n  recorder.connect(context.destination);\n\n  recorder.onaudioprocess = function (e) {\n    var left = e.inputBuffer.getChannelData(0);\n    var right = e.inputBuffer.getChannelData(1);\n    stats.leftChannel.push(new Float32Array(left));\n    stats.rightChannel.push(new Float32Array(right));\n    stats.recordingLength += bufferSize;\n  };\n\n  return {\n    stats: stats,\n    sampleRate: sampleRate,\n    stop: function stop() {\n      stream.getTracks().forEach(function (track) {\n        return track.stop();\n      });\n      context.close();\n      recorder.disconnect();\n      audioInput.disconnect();\n    }\n  };\n}\n\nfunction proccesAudio(_ref) {\n  var _ref$stats = _ref.stats,\n      leftChannel = _ref$stats.leftChannel,\n      rightChannel = _ref$stats.rightChannel,\n      recordingLength = _ref$stats.recordingLength,\n      sampleRate = _ref.sampleRate,\n      stop = _ref.stop;\n  stop();\n  var leftBuffer = mergeBuffers(leftChannel, recordingLength);\n  var rightBuffer = mergeBuffers(rightChannel, recordingLength);\n  var interleaved = interleave(leftBuffer, rightBuffer);\n  var buffer = new ArrayBuffer(44 + interleaved.length * 2);\n  var view = new DataView(buffer);\n  writeUTFBytes(view, 0, 'RIFF');\n  view.setUint32(4, 44 + interleaved.length * 2, true);\n  writeUTFBytes(view, 8, 'WAVE');\n  writeUTFBytes(view, 12, 'fmt ');\n  view.setUint32(16, 16, true);\n  view.setUint16(20, 1, true);\n  view.setUint16(22, 2, true);\n  view.setUint32(24, sampleRate, true);\n  view.setUint32(28, sampleRate * 4, true);\n  view.setUint16(32, 4, true);\n  view.setUint16(34, 16, true);\n  writeUTFBytes(view, 36, 'data');\n  view.setUint32(40, interleaved.length * 2, true);\n  var lng = interleaved.length;\n  var index = 44;\n  var volume = 1;\n\n  for (var i = 0; i < lng; i++) {\n    view.setInt16(index, interleaved[i] * (0x7fff * volume), true);\n    index += 2;\n  }\n\n  var blob = new Blob([view], {\n    type: 'audio/wav'\n  });\n  var audioUrl = URL.createObjectURL(blob);\n  return {\n    buffer: buffer,\n    audioUrl: audioUrl,\n    blob: blob\n  };\n}\n\nfunction mergeBuffers(channelBuffer, recordingLength) {\n  var result = new Float32Array(recordingLength);\n  var offset = 0;\n  var lng = channelBuffer.length;\n\n  for (var i = 0; i < lng; i++) {\n    var buffer = channelBuffer[i];\n    result.set(buffer, offset);\n    offset += buffer.length;\n  }\n\n  return result;\n}\n\nfunction interleave(leftChannel, rightChannel) {\n  var length = leftChannel.length + rightChannel.length;\n  var result = new Float32Array(length);\n  var inputIndex = 0;\n\n  for (var index = 0; index < length;) {\n    result[index++] = leftChannel[inputIndex];\n    result[index++] = rightChannel[inputIndex];\n    inputIndex++;\n  }\n\n  return result;\n}\n\nfunction writeUTFBytes(view, offset, string) {\n  var lng = string.length;\n\n  for (var i = 0; i < lng; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\n\nfunction useRecorder() {\n  var _React$useState = useState(),\n      audio = _React$useState[0],\n      setAudio = _React$useState[1];\n\n  var _React$useState2 = useState(),\n      player = _React$useState2[0],\n      setPlayer = _React$useState2[1];\n\n  var recorderInstance = useRef(function () {\n    return undefined;\n  });\n\n  var start = function start() {\n    recorderInstance.current = AudioRecorder();\n  };\n\n  var stop = function stop() {\n    try {\n      recorderInstance.current.stopRecord();\n      setAudio(recorderInstance.current.recording.audio);\n      setPlayer(recorderInstance.current.recording.player);\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return {\n    start: start,\n    stop: stop,\n    audio: audio,\n    player: player\n  };\n}\n\nvar Recorder = function Recorder() {\n  return createElement(Fragment, null, \"Only Hook is implemented currently.\");\n};\n\nexport { Recorder, useRecorder };","map":{"version":3,"mappings":"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","names":["askForMic","navigator","mediaDevices","getUserMedia","audio","video","stopRecording","recorder","proccesAudio","createPlayerStop","_stopRecording","player","Audio","audioUrl","record","compose","setUpRecording","AudioRecorder","micRef","current","recording","startRecord","stopRecord","Object","assign","then","stream","Error","context","AudioContext","sampleRate","stats","leftChannel","rightChannel","recordingLength","audioInput","createMediaStreamSource","analyser","createAnalyser","connect","bufferSize","createScriptProcessor","destination","onaudioprocess","e","left","inputBuffer","getChannelData","right","push","Float32Array","stop","getTracks","forEach","track","close","disconnect","leftBuffer","mergeBuffers","rightBuffer","interleaved","interleave","buffer","ArrayBuffer","length","view","DataView","writeUTFBytes","setUint32","setUint16","lng","index","volume","i","setInt16","blob","Blob","type","URL","createObjectURL","channelBuffer","result","offset","set","inputIndex","string","setUint8","charCodeAt","useRecorder","React","setAudio","setPlayer","recorderInstance","undefined","start","Recorder"],"sources":["C:\\Users\\Michael\\Documents\\GitHub\\fromagent\\client\\node_modules\\use-recorder\\src\\recorder.utils.ts","C:\\Users\\Michael\\Documents\\GitHub\\fromagent\\client\\node_modules\\use-recorder\\src\\index.tsx"],"sourcesContent":["import compose from 'compose-function'\n\n/* eslint-disable prettier/prettier */\nconst stopRecording = (recorder) => () => proccesAudio(recorder)\nconst createPlayerStop = (_stopRecording) => () => {\n  const audio = _stopRecording()\n  return { player: new Audio(audio.audioUrl), audio }\n}\n\nconst record = compose(createPlayerStop, stopRecording, setUpRecording)\n\nexport function AudioRecorder() {\n  const micRef = { current: {} }\n  const recorder: any = { current: {} }\n  const recording: any = {}\n\n  const startRecord = () => {\n    if (micRef && micRef.current) {\n      recorder.current = record(micRef.current)\n    }\n  }\n\n  const stopRecord = () => {\n    Object.assign(recording, recorder.current())\n  }\n\n  askForMic().then((stream: MediaStream) => {\n    if (!stream) throw new Error('no source to record from')\n    micRef.current = stream\n    startRecord()\n  })\n\n  return {\n    startRecord,\n    stopRecord,\n    recording\n  }\n}\n\nfunction setUpRecording(stream) {\n  const context = new AudioContext({ sampleRate: 44100 })\n  const sampleRate = context.sampleRate\n  const stats: any = {\n    leftChannel: [],\n    rightChannel: [],\n    recordingLength: 0\n  }\n  // creates a gain node\n  // const volume = context.createGain()\n  // creates an audio node from the microphone incoming stream\n  const audioInput = context.createMediaStreamSource(stream)\n  // Create analyser\n  const analyser = context.createAnalyser()\n  // connect audio input to the analyser\n  audioInput.connect(analyser)\n\n  // connect analyser to the volume control\n  // analyser.connect(volume);\n  const bufferSize = 2048\n  const recorder = context.createScriptProcessor(bufferSize, 2, 2)\n\n  // we connect the volume control to the processor\n  // volume.connect(recorder);\n\n  analyser.connect(recorder)\n\n  // finally connect the processor to the output\n  recorder.connect(context.destination)\n\n  recorder.onaudioprocess = function (e) {\n    const left = e.inputBuffer.getChannelData(0)\n    const right = e.inputBuffer.getChannelData(1)\n    // we clone the samples\n    stats.leftChannel.push(new Float32Array(left))\n    stats.rightChannel.push(new Float32Array(right))\n    stats.recordingLength += bufferSize\n  }\n  return {\n    stats,\n    sampleRate,\n    stop: () => {\n      stream.getTracks().forEach((track) => track.stop())\n      context.close()\n      recorder.disconnect()\n      audioInput.disconnect()\n    }\n  }\n}\n\ntype Recording = {\n  stats: {\n    leftChannel: any[]\n    rightChannel: any[]\n    recordingLength: number\n  }\n  sampleRate: number\n  stop: () => any\n}\n\ntype RecordingResult = {\n  buffer: ArrayBuffer\n  audioUrl: string\n  blob: Blob\n}\nasync function askForMic() {\n  return navigator.mediaDevices.getUserMedia({\n    audio: true,\n    video: false\n  })\n}\n\n// async function getMics() {\n//   const devices = await navigator.mediaDevices.enumerateDevices()\n//   const mics =\n//     devices && devices.filter((device) => device.kind === 'audioinput')\n// }\n\n//\nfunction proccesAudio({\n  stats: { leftChannel, rightChannel, recordingLength },\n  sampleRate,\n  stop\n}: Recording): RecordingResult {\n  stop()\n  // we flat the left and right channels down\n  const leftBuffer = mergeBuffers(leftChannel, recordingLength)\n  const rightBuffer = mergeBuffers(rightChannel, recordingLength)\n  // we interleave both channels together\n  const interleaved = interleave(leftBuffer, rightBuffer)\n\n  /// ////////// WAV Encode /////////////////\n  // from http://typedarray.org/from-microphone-to-wav-with-getusermedia-and-web-audio/\n  //\n\n  // we create our wav file\n  const buffer = new ArrayBuffer(44 + interleaved.length * 2)\n  const view = new DataView(buffer)\n\n  // RIFF chunk descriptor\n  writeUTFBytes(view, 0, 'RIFF')\n  view.setUint32(4, 44 + interleaved.length * 2, true)\n  writeUTFBytes(view, 8, 'WAVE')\n  // FMT sub-chunk\n  writeUTFBytes(view, 12, 'fmt ')\n  view.setUint32(16, 16, true)\n  view.setUint16(20, 1, true)\n  // stereo (2 channels)\n  view.setUint16(22, 2, true)\n  view.setUint32(24, sampleRate, true)\n  view.setUint32(28, sampleRate * 4, true)\n  view.setUint16(32, 4, true)\n  view.setUint16(34, 16, true)\n  // data sub-chunk\n  writeUTFBytes(view, 36, 'data')\n  view.setUint32(40, interleaved.length * 2, true)\n\n  // write the PCM samples\n  const lng = interleaved.length\n  let index = 44\n  const volume = 1\n  for (let i = 0; i < lng; i++) {\n    view.setInt16(index, interleaved[i] * (0x7fff * volume), true)\n    index += 2\n  }\n\n  // our final binary blob\n  const blob = new Blob([view], { type: 'audio/wav' })\n\n  const audioUrl = URL.createObjectURL(blob)\n  // console.log('BLOB ', blob)\n  // console.log('URL ', audioUrl)\n  return { buffer, audioUrl, blob }\n}\n\nfunction mergeBuffers(channelBuffer, recordingLength) {\n  const result = new Float32Array(recordingLength)\n  let offset = 0\n  const lng = channelBuffer.length\n  // debugger\n  for (let i = 0; i < lng; i++) {\n    const buffer = channelBuffer[i]\n    result.set(buffer, offset)\n    offset += buffer.length\n  }\n  return result\n}\n\nfunction interleave(leftChannel, rightChannel) {\n  const length = leftChannel.length + rightChannel.length\n  const result = new Float32Array(length)\n\n  let inputIndex = 0\n\n  for (let index = 0; index < length; ) {\n    result[index++] = leftChannel[inputIndex]\n    result[index++] = rightChannel[inputIndex]\n    inputIndex++\n  }\n  return result\n}\n\nfunction writeUTFBytes(view, offset, string) {\n  const lng = string.length\n  for (let i = 0; i < lng; i++) {\n    view.setUint8(offset + i, string.charCodeAt(i))\n  }\n}\n","/* eslint-disable no-unused-vars */\nimport * as React from 'react'\nimport { AudioRecorder } from './recorder.utils'\n\nexport function useRecorder() {\n  const [audio, setAudio] = React.useState<File>()\n  const [player, setPlayer] = React.useState<HTMLAudioElement>()\n  const recorderInstance = React.useRef<any>(() => undefined)\n\n  const start = () => {\n    recorderInstance.current = AudioRecorder()\n  }\n\n  const stop = async () => {\n    recorderInstance.current.stopRecord()\n    setAudio(recorderInstance.current.recording.audio)\n    setPlayer(recorderInstance.current.recording.player)\n  }\n\n  return {\n    start,\n    stop,\n    audio,\n    player\n  }\n}\n\nexport const Recorder = () => {\n  return <React.Fragment>Only Hook is implemented currently.</React.Fragment>\n}\n"]},"metadata":{},"sourceType":"module"}